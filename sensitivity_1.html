<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ì˜ë£Œì¢…ì‚¬ì í™ì—­ ë©´ì—­ ì „ëµ ë¯¼ê°ë„ ë¶„ì„ (Sensitivity Sweep)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <style>
    .chart-container { position: relative; width: 100%; height: 350px; }
    .control-card { background: #ffffff; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); }
    input[type="number"] { accent-color: #2563eb; }
  </style>
</head>

<body class="bg-slate-50 text-slate-900 font-sans leading-relaxed">

<header class="bg-white border-b border-slate-200 sticky top-0 z-50">
  <div class="max-w-7xl mx-auto px-6 h-16 flex items-center justify-between">
    <div class="flex items-center gap-2">
      <span class="text-2xl">ğŸ¥</span>
      <h1 class="text-lg font-bold text-slate-800">HCW Measles Immunity Strategy Dashboard</h1>
    </div>
    <div class="text-xs text-slate-400 font-mono">Logic: mu_1_sensitivity_1.m</div>
  </div>
</header>

<main class="max-w-7xl mx-auto px-6 py-10 space-y-10">

  <section class="grid lg:grid-cols-4 gap-8">
    <!-- Controls (Left Column) -->
    <div class="lg:col-span-1 space-y-6">
      <div class="control-card space-y-4">
        <h2 class="text-sm font-bold text-slate-500 uppercase tracking-wider">Parameter Input</h2>
        <div>
          <label class="block text-sm font-medium text-slate-700 mb-1">Turnover Scaling (Îµ)</label>
          <input type="number" id="epsilonInput" value="0" step="0.01" min="0"
                 class="w-full px-3 py-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none">
          <p class="text-[10px] text-slate-400 mt-1">pde_pop.mì˜ out_amt / inflow_weightì— ë°˜ì˜ (ê¸°ë³¸ê°’: 0)</p>
        </div>

        <button id="runBtn"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg transition-all shadow-md active:scale-95">
          ğŸ”„ ì‹¤í–‰ (Î¼1=1..23 Sweep)
        </button>

        <div class="text-[11px] text-slate-500 space-y-2 border-t pt-4 border-slate-100">
          <div class="font-bold text-slate-700">Scenarios:</div>
          <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-black"></span> <b>Baseline:</b> to_full, v_t=50</div>
          <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-sm bg-[#C46E41]"></span> <b>Scenario 1:</b> to_neg, v_t=0</div>
          <div class="flex items-center gap-2"><span class="w-0 h-0 border-l-[4px] border-l-transparent border-r-[4px] border-r-transparent border-b-[8px] border-b-[#EDA00D]"></span> <b>Scenario 2:</b> to_full, v_t=0</div>
        </div>
        <div id="status" class="text-[11px] text-slate-500 mt-2"></div>
      </div>
    </div>

    <!-- Charts (Right Column) -->
    <div class="lg:col-span-3 space-y-6">
      <div class="bg-white p-8 rounded-2xl shadow-sm border border-slate-100">
        <h2 class="text-2xl font-bold mb-6 text-slate-800">Sensitivity Analysis Results</h2>
        
        <div class="grid lg:grid-cols-3 gap-6">
          <!-- Chart A: S_Full -->
          <div class="bg-slate-50 p-4 rounded-xl border border-slate-200">
            <h3 class="text-sm font-bold text-center text-slate-600 mb-3">(A) S_Full Proportion</h3>
            <div class="chart-container"><canvas id="chartFull"></canvas></div>
          </div>
          
          <!-- Chart B: S_Part -->
          <div class="bg-slate-50 p-4 rounded-xl border border-slate-200">
            <h3 class="text-sm font-bold text-center text-slate-600 mb-3">(B) S_Part Proportion</h3>
            <div class="chart-container"><canvas id="chartPart"></canvas></div>
          </div>
          
          <!-- Chart C: S_Neg -->
          <div class="bg-slate-50 p-4 rounded-xl border border-slate-200">
            <h3 class="text-sm font-bold text-center text-slate-600 mb-3">(C) S_Neg Proportion</h3>
            <div class="chart-container"><canvas id="chartNeg"></canvas></div>
          </div>
        </div>

      </div>
    </div>
  </section>
</main>

<footer class="max-w-7xl mx-auto px-6 py-10 border-t border-slate-200 text-center text-slate-400 text-xs">
  <p>ë³¸ ì‹œë®¬ë ˆì´í„°ëŠ” MATLAB ì—°êµ¬ ì½”ë“œ(mu_1_sensitivity_1.m)ë¥¼ ì›¹ í‘œì¤€ ê¸°ìˆ ë¡œ êµ¬í˜„í•œ ë„êµ¬ì…ë‹ˆë‹¤.</p>
</footer>

<script>
/** =========================
 * Constants & Colors
 * ========================= */
const N_TOT = 2320;
const T_SPAN = 41;
const MU_RANGE = Array.from({length: 23}, (_, i) => i + 1);

// MATLAB Colors
const COLOR_BASE = '#000000';             // Black
const COLOR_S1   = 'rgb(196, 110, 65)';   // Orange
const COLOR_S2   = 'rgb(237, 176, 33)';   // Yellow/Gold (approximate)

/** =========================
 * Mathematical Helper Functions
 * ========================= */
function simpsonIntegrate(f, t, n){
  if (t <= 0) return 0;
  n = Math.max(200, Math.floor(n||400));
  if (n % 2 === 1) n += 1;
  const h = t / n;
  let s = f(0) + f(t);
  for (let i=1; i<n; i++){
    const x = i*h;
    s += (i%2===0 ? 2 : 4) * f(x);
  }
  return (h/3) * s;
}

function gampdf(x, a, b){ if (x < 0) return 0; return jStat.gamma.pdf(x, a, b); }
function gamcdf(x, a, b){ if (x < 0) return 0; return jStat.gamma.cdf(x, a, b); }

function clamp(x, lo, hi) { return Math.min(Math.max(x, lo), hi); }

/** =========================
 * Simulation Logic (EstImm & pdePop)
 * ========================= */
function EstImm(param, tspan, intSteps){
  const P0 = 1.0;
  const alpha1 = param[0], mu1 = param[1], alpha2 = param[2];
  const beta1 = mu1 / alpha1, beta2 = (24 - mu1) / alpha2;
  const P = [], Part = [], Neg = [];
  for (let i=0; i<tspan.length; i++){
    const t = tspan[i];
    const F1 = gamcdf(t, alpha1, beta1);
    const P_t = P0 * (1 - F1);
    if (t === 0){
      P[i] = P_t; Part[i] = Number.EPSILON; Neg[i] = Number.EPSILON;
    } else {
      const integrand = (u) => gampdf(u, alpha1, beta1) * gamcdf(t-u, alpha2, beta2);
      const neg = P0 * simpsonIntegrate(integrand, t, intSteps) + Number.EPSILON;
      P[i] = P_t; Neg[i] = neg; Part[i] = 1 - P_t - neg;
    }
  }
  return { Full: P, Part, Neg };
}

// pde_pop.m êµ¬í˜„
function pdePop(year, epsilon){
  const Amax = 42, L = Amax, Ntot = 2320;
  const y_raw = [1,1,2,19,52,136,158,169,152,150,143,115,98,67,66,50,45,44,43,52,48,53,47,30,46,31,29,35,27,28,23,32,26,27,14,38,38,37,37,37,37,37];
  let D = y_raw.map(v => v/2320);
  const sumD = D.reduce((a,b)=>a+b,0);
  D = D.map(v => v/sumD * Ntot);
  
  // outflow & inflow_weight
  const out_amt = new Array(L).fill(0);
  for (let a=0; a<L-1; a++) out_amt[a] = Math.max(D[a]-D[a+1], 0) + D[a]*epsilon;
  out_amt[L-1] = D[L-1] + D[L-1]*epsilon;
  
  const inflow_weight = new Array(L).fill(0);
  inflow_weight[0] = D[0] + D[0]*epsilon;
  for (let a=1; a<L; a++) inflow_weight[a] = Math.max(D[a]-D[a-1], 0) + D[a]*epsilon;
  
  let sumW = inflow_weight.reduce((a,b)=>a+b,0);
  
  // epsilon=0ì¼ ë•Œ sumWê°€ 0ì´ ë˜ì–´ NaNì´ ë°œìƒí•˜ëŠ” ë¬¸ì œ í•´ê²°
  if (sumW > 0) {
      for (let a=0; a<L; a++) inflow_weight[a] /= sumW;
  } else {
      // sumWê°€ 0ì´ë©´(ë§¤ìš° ë“œë¬¸ ê²½ìš°ì§€ë§Œ epsilon=0 ë“±ì—ì„œ ë°œìƒ ê°€ëŠ¥), ê· ë“± ë¶„í¬ë‚˜ 0ìœ¼ë¡œ ì„¤ì •
      // ì—¬ê¸°ì„œëŠ” 0ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ NaN ì „íŒŒ ë°©ì§€ (ë˜ëŠ” ì•ˆì „í•˜ê²Œ 1/L)
      for (let a=0; a<L; a++) inflow_weight[a] = 0; 
  }
  
  // P: Initial Stock (L x (year+1))
  const P = Array.from({length:L}, ()=> new Array(year+1).fill(0));
  for (let a=0; a<L; a++) P[a][0] = D[a];
  
  // C: Cohorts (L x year)
  let C = Array.from({length:L}, ()=> new Array(year).fill(0));
  
  for (let t=1; t<=year; t++){
    // 1) Outflow calculation
    let TotalStock = new Array(L).fill(0);
    for (let a=0; a<L; a++){
      let s = P[a][t-1];
      for (let k=0; k<t-1; k++) s += C[a][k];
      TotalStock[a] = Math.max(s, 1e-9);
    }
    
    const take = new Array(L);
    for (let a=0; a<L; a++) take[a] = Math.min(out_amt[a], TotalStock[a]);
    
    const out_P = new Array(L), P_after = new Array(L);
    for (let a=0; a<L; a++){
      // TotalStock[a]ê°€ 0ì— ê°€ê¹Œìš°ë©´ ë‚˜ëˆ—ì…ˆ ì£¼ì˜ (ìœ„ì—ì„œ 1e-9ë¡œ ë°©ì§€í•¨)
      out_P[a] = (P[a][t-1] / TotalStock[a]) * take[a];
      P_after[a] = Math.max(P[a][t-1] - out_P[a], 0);
    }
    
    let C_after = Array.from({length:L}, ()=> new Array(t-1).fill(0));
    let out_C_all_sum = 0;
    if (t > 1){
      for (let k=0; k<t-1; k++){
        for (let a=0; a<L; a++){
          const out_C_k = (C[a][k] / TotalStock[a]) * take[a];
          C_after[a][k] = Math.max(C[a][k] - out_C_k, 0);
          out_C_all_sum += out_C_k;
        }
      }
    }
    
    // 2) Aging
    const P_next = new Array(L).fill(0);
    for (let a=1; a<L; a++) P_next[a] = P_after[a-1];
    
    const C_next = Array.from({length:L}, ()=> new Array(year).fill(0));
    if (t > 1){
      for (let k=0; k<t-1; k++) for (let a=1; a<L; a++) C_next[a][k+1] = C_after[a-1][k];
    }
    
    // 3) New Cohort
    const out_total = out_P.reduce((s,x)=>s+x,0) + out_C_all_sum;
    for (let a=0; a<L; a++) C_next[a][0] = out_total * inflow_weight[a];
    
    // 4) Record
    for (let a=0; a<L; a++) P[a][t] = P_next[a];
    C = C_next;
  }
  return { C, P };
}

/** =========================
 * Scenario Logic: Matrix NoVac To Full
 * ========================= */
function matrixNoVacToFull(param, year, v_t, epsilon){
  // v_t ì´ì „: ë¯¸ì ‘ì¢…, v_t ì´í›„: ì‹ ê·œ ì…ì‚¬ì ì „ì› ì ‘ì¢…
  
  const tspan = Array.from({length: 51+20+year + 1}, (_,i)=>i);
  const IMM_G1 = EstImm(param, tspan, 400); // 0-based array. t=0 is index 0.
  
  // G2: [Full, Part, Neg]
  const g2full = [78,88,78,97,92,91,94,98,100,96,91,98,98,90,96,94,97,91,87,97,100,93,96,96,100,100,100,93].map(v=>v/100);
  const IMM_G2 = g2full.map(v => [v, 0, 1-v]);
  
  const resY = pdePop(year, epsilon);
  const Q0 = resY.C; // Population Structure (L x year)
  
  let pop_matrix = null;
  
  for (let T=1; T<=year; T++){
    const res = pdePop(T, epsilon);
    const P = res.P;
    
    // [Full, Part, Neg] (Time x Age)
    pop_matrix = [
        Array.from({length:T+1}, ()=>new Array(42).fill(0)), 
        Array.from({length:T+1}, ()=>new Array(42).fill(0)), 
        Array.from({length:T+1}, ()=>new Array(42).fill(0))
    ];
    
    const limit_idx = Math.min(7+T, 42);
    
    // 1. G1 Group (Younger)
    for (let i=0; i<3; i++){
        // [Incumbents] - Tenure 0 (Before policy)
        for (let a=0; a<limit_idx; a++){
            // MATLAB: IMM_G1(15:14+limit, i)
            // JS: t=14 is index 14
            const t_imm = 14 + a;
            const imm = (i===0?IMM_G1.Full[t_imm] : i===1?IMM_G1.Part[t_imm] : IMM_G1.Neg[t_imm]);
            pop_matrix[i][0][a] = imm * P[a][T];
        }
        
        // [Recruits] - Tenure 1 to T
        for (let j=2; j<=T+1; j++){
            const tenure = j-1; // 1 to T
            const recruit_year = T - tenure + 1;
            
            let pop_count = new Array(limit_idx).fill(0);
            if (tenure <= Q0[0].length) {
                for (let a=0; a<limit_idx; a++) pop_count[a] = Q0[a][tenure-1];
            }
            
            if (recruit_year <= v_t) {
                // Before v_t -> Unvaccinated (Age based)
                for (let a=0; a<limit_idx; a++){
                    const t_imm = 14 + a; 
                    const imm = (i===0?IMM_G1.Full[t_imm] : i===1?IMM_G1.Part[t_imm] : IMM_G1.Neg[t_imm]);
                    pop_matrix[i][j-1][a] = pop_count[a] * imm;
                }
            } else {
                // After v_t -> Vaccinated (Tenure based)
                // MATLAB Logic: imm_idx_V = j-1; (j starts at 2, so idx starts at 1, t=0)
                // JS Array Index (t): t = imm_idx_V - 1 = j - 2.
                let tV = j - 2;
                if (tV < 0) tV = 0;
                
                const imm = (i===0?IMM_G1.Full[tV] : i===1?IMM_G1.Part[tV] : IMM_G1.Neg[tV]);
                for (let a=0; a<limit_idx; a++){
                    pop_matrix[i][j-1][a] = pop_count[a] * imm;
                }
            }
        }
    }
    
    // 2. G2/G3 Group (Older)
    for (const i of [0, 2]){ // Only Full(0) and Neg(2) used for G2
      const idx_start = 8 + T;
      const idx_end = Math.min(42, 35 + T);
      
      if (idx_start <= 42){
        // G2 Probs
        const start0 = idx_start - 1; 
        const end0 = idx_end - 1;
        const len_req = end0 - start0 + 1;
        
        let G2_probs = new Array(len_req).fill(0);
        if (T > 7){
            // MATLAB: g2_idx = T-6:28 -> JS: T-7 .. 27
            for (let m=0; m<len_req; m++){
                const idx = clamp((T - 7) + m, 0, 27);
                G2_probs[m] = IMM_G2[idx][i];
            }
        } else {
            for (let m=0; m<len_req; m++) G2_probs[m] = IMM_G2[m][i];
        }
        
        // [Incumbents]
        for (let m=0; m<len_req; m++){
             const a = start0 + m;
             pop_matrix[i][0][a] = G2_probs[m] * P[a][T];
        }
        
        // [Recruits]
        for (let j=2; j<=T+1; j++){
             const tenure = j-1;
             const recruit_year = T - tenure + 1;
             
             let pop_count_g2 = new Array(len_req).fill(0);
             if (tenure <= Q0[0].length){
                 for (let m=0; m<len_req; m++) pop_count_g2[m] = Q0[start0+m][tenure-1];
             }
             
             if (recruit_year <= v_t){
                 // Unvaccinated -> Natural Immunity
                 for (let m=0; m<len_req; m++){
                     pop_matrix[i][j-1][start0+m] = pop_count_g2[m] * G2_probs[m];
                 }
             } else {
                 // Vaccinated -> 100% Full (Booster)
                 if (i === 0) { // Full
                     for (let m=0; m<len_req; m++) pop_matrix[i][j-1][start0+m] = pop_count_g2[m] * 1.0;
                 } else { // Part/Neg
                     for (let m=0; m<len_req; m++) pop_matrix[i][j-1][start0+m] = 0;
                 }
             }
        }
      }
    }
    
    // S3 fix
    const S3 = [38,38,37,37,37,37,37];
    if (T < 7){
        const from = 36 + T; 
        for (let col=from; col<=42; col++){
            pop_matrix[0][0][col-1] = S3[col-from];
        }
    }
  }
  return pop_matrix;
}

/** =========================
 * Scenario Logic: Matrix NoVac To Neg
 * ========================= */
function matrixNoVacToNeg(param, year, v_t, epsilon){
  const tspan = Array.from({length: 51 + 20 + year + 1}, (_, i) => i);
  const IMM_G1 = EstImm(param, tspan, 400);
  
  // G2: [Full, Part, Neg]
  const g2full = [78,88,78,97,92,91,94,98,100,96,91,98,98,90,96,94,97,91,87,97,100,93,96,96,100,100,100,93].map(v => v/100);
  const IMM_G2 = g2full.map(v => [v, 0, 1 - v]);
  const G1_Neg = IMM_G1.Neg;
  
  const resY = pdePop(year, epsilon);
  const Q0 = resY.C; // L x year (Tenure based columns)
  
  // Q1_: Vaccination Ratio Matrix (Age x Cohort)
  const Q1_ = Array.from({length: 42}, () => new Array(year).fill(0));
  const max_row = 42;
  
  // Policy Loop
  for (let T=1; T<=year; T++){
      if (T > v_t){
          // T > v_t: Vaccinate recruits entering at year T
          const idx_limit = Math.min(T + 7, max_row);
          
          let Neg_vaccination = new Array(idx_limit).fill(0);
          for (let a=0; a<idx_limit; a++){
              // t_imm = 18 + a (Matches MATLAB 19 + a - 1)
              Neg_vaccination[a] = Q0[a][0] * (G1_Neg[18+a] || 0);
          }
          
          const col_idx = year - T; // 0-based index for Q1_ column
          const zeros_len = Math.min(year - T, 42);
          
          // Fill 0s
          for (let z=0; z<zeros_len; z++) Q1_[z][col_idx] = 0;
          
          // Fill Ratios
          for (let a=0; a<idx_limit; a++){
             const row = zeros_len + a;
             if (row < 42){
                 const denom = Q0[a][0];
                 const val = (denom > 0) ? (Neg_vaccination[a] / denom) : 0;
                 Q1_[row][col_idx] = val;
             }
          }
      }
  }
  
  // V & Q Calculation
  const V = Array.from({length: 42}, () => new Array(year).fill(0));
  const Q = Array.from({length: 42}, () => new Array(year).fill(0));
  
  for (let a=0; a<42; a++){
      for (let k=0; k<year; k++){
          const q0 = Q0[a][k];
          const q1 = Q1_[a][k];
          V[a][k] = q0 * q1;
          Q[a][k] = q0 * (1 - q1);
      }
  }
  
  let pop_matrix = null;
  
  // Main Simulation Loop
  for (let T=1; T<=year; T++){
      const res = pdePop(T, epsilon);
      const P = res.P;
      const C = res.C; // Used for G2 recruits
      
      pop_matrix = [
        Array.from({length: T + 1}, () => new Array(42).fill(0)),
        Array.from({length: T + 1}, () => new Array(42).fill(0)),
        Array.from({length: T + 1}, () => new Array(42).fill(0)),
      ];
      
      const idx_limit = Math.min(7 + T, max_row);
      
      for (let i=0; i<3; i++){
          // Incumbents
          for (let a=0; a<idx_limit; a++){
              const t_imm = 14 + a;
              const imm = (i===0 ? IMM_G1.Full[t_imm] : i===1 ? IMM_G1.Part[t_imm] : IMM_G1.Neg[t_imm]);
              pop_matrix[i][0][a] = imm * P[a][T];
          }
          
          // Recruits
          for (let j=2; j<=T+1; j++){
              const tenure_idx = j - 2; // JS 0-based tenure index (MATLAB j-1 corresponds to this)
              
              // Age based immunity (for Q)
              // Tenure based immunity (for V)
              let imm_idx_V = j - 2;
              if (imm_idx_V < 0) imm_idx_V = 0;
              const imm_ten = (i===0 ? IMM_G1.Full[imm_idx_V] : i===1 ? IMM_G1.Part[imm_idx_V] : IMM_G1.Neg[imm_idx_V]);
              
              for (let a=0; a<idx_limit; a++){
                  const t_age = 14 + a;
                  const imm_age = (i===0 ? IMM_G1.Full[t_age] : i===1 ? IMM_G1.Part[t_age] : IMM_G1.Neg[t_age]);
                  
                  const q_val = (Q[a] && Q[a][tenure_idx] !== undefined) ? Q[a][tenure_idx] : 0;
                  const v_val = (V[a] && V[a][tenure_idx] !== undefined) ? V[a][tenure_idx] : 0;
                  
                  pop_matrix[i][j-1][a] = imm_age * q_val + imm_ten * v_val;
              }
          }
      }
      
      // G2/G3 Group
      for (const i of [0, 2]){
          const idx_start = 8 + T;
          const idx_end = Math.min(42, 35 + T);
          
          if (idx_start <= 42){
              const start0 = idx_start - 1;
              const len = idx_end - idx_start + 1;
              
              let G2_probs = new Array(len).fill(0);
              if (T > 7){
                  for (let m=0; m<len; m++) {
                      const idx = clamp((T-7)+m, 0, 27);
                      G2_probs[m] = IMM_G2[idx][i];
                  }
              } else {
                  for (let m=0; m<len; m++) G2_probs[m] = IMM_G2[m][i];
              }
              
              // Incumbents
              for (let m=0; m<len; m++) pop_matrix[i][0][start0+m] = G2_probs[m] * P[start0+m][T];
              
              // Recruits
              // Note: matrix_novac_to_neg.m simply applies G2 natural immunity
              for (let j=2; j<=T+1; j++){
                  const tenure_idx = j - 2;
                  // Use C_mat from pdePop logic. In this loop context, C is available.
                  // C columns: 0 is newest. tenure_idx=0 means newest. 
                  for (let m=0; m<len; m++){
                      const val = (C[start0+m] && C[start0+m][tenure_idx] !== undefined) ? C[start0+m][tenure_idx] : 0;
                      pop_matrix[i][j-1][start0+m] = G2_probs[m] * val;
                  }
              }
          }
      }
      
      // S3 Fix
      const S3 = [38,38,37,37,37,37,37];
      if (T < 7){
        const from = 36 + T; 
        for (let col=from; col<=42; col++){
            pop_matrix[0][0][col-1] = S3[col-from];
        }
      }
  }
  return pop_matrix;
}


function runSimulation(func, theta, t_span, v_t, epsilon){
  const pm = func(theta, t_span, v_t, epsilon);
  let f=0, p=0, n=0;
  for (let i=0; i<pm[0].length; i++) for (let j=0; j<pm[0][i].length; j++){ f+=pm[0][i][j]; p+=pm[1][i][j]; n+=pm[2][i][j]; }
  return [f/N_TOT, p/N_TOT, n/N_TOT];
}

/** =========================
 * Main App Logic
 * ========================= */
let charts = { full:null, part:null, neg:null };

function initCharts(){
  const commonOptions = {
      responsive:true, 
      maintainAspectRatio:false, 
      plugins:{ legend:{ display:false }, title: { display:false } }, 
      scales:{ 
        y:{ min:0, max:1, title:{display:true, text:'Proportion'} }, 
        x:{ title:{display:true, text:'Î¼1'}, ticks:{ stepSize: 2 } } 
      } 
  };

  const createChart = (id, color) => new Chart(document.getElementById(id), {
    type: 'line',
    data: { 
      labels: MU_RANGE, 
      datasets: [
        { label:'Baseline',   data:[], borderColor:COLOR_BASE, backgroundColor:COLOR_BASE, pointStyle:'circle', pointRadius:3, borderWidth:1.5 },
        { label:'Scenario 1', data:[], borderColor:COLOR_S1,   backgroundColor:COLOR_S1,   pointStyle:'rect',   pointRadius:3, borderWidth:1.5 },
        { label:'Scenario 2', data:[], borderColor:COLOR_S2,   backgroundColor:COLOR_S2,   pointStyle:'triangle', pointRadius:4, borderWidth:1.5 }
      ]
    },
    options: commonOptions
  });

  charts.full = createChart('chartFull');
  charts.part = createChart('chartPart');
  charts.neg  = createChart('chartNeg');
}

async function runSweep(){
  const btn = document.getElementById('runBtn');
  // NaNì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ parseFloatë§Œ ì‚¬ìš©
  const eps = parseFloat(document.getElementById('epsilonInput').value); 
  const statusDiv = document.getElementById('status');
  
  if (isNaN(eps) || eps < 0) {
      statusDiv.innerHTML = "Error: Invalid epsilon (must be >= 0)";
      return;
  }
  
  btn.disabled = true; btn.innerHTML = 'â³ ê³„ì‚° ì¤‘...';
  statusDiv.innerHTML = "Calculations started...";

  try {
    const resB = [], resS1 = [], resS2 = [];
    
    // Sweep calculation
    for (let mu1 of MU_RANGE){
      const theta = [1, mu1, 1, 0];
      
      // Case 1: Baseline (v_t = 50, NoVacToFull)
      resB.push(runSimulation(matrixNoVacToFull, theta, T_SPAN, 50, eps));
      
      // Case 2: Scenario 1 (v_t = 0, NoVacToNeg)
      resS1.push(runSimulation(matrixNoVacToNeg, theta, T_SPAN, 0, eps));
      
      // Case 3: Scenario 2 (v_t = 0, NoVacToFull)
      resS2.push(runSimulation(matrixNoVacToFull, theta, T_SPAN, 0, eps));
      
      if (mu1 % 3 === 0) {
          statusDiv.innerHTML = `Calculating mu1 = ${mu1} / 23`;
          await new Promise(r=>setTimeout(r,0));
      }
    }

    statusDiv.innerHTML = "Rendering charts...";

    const updateChart = (chart, idx) => {
        chart.data.datasets[0].data = resB.map(d=>d[idx]);
        chart.data.datasets[1].data = resS1.map(d=>d[idx]);
        chart.data.datasets[2].data = resS2.map(d=>d[idx]);
        chart.update();
    };
    
    updateChart(charts.full, 0); // Full
    updateChart(charts.part, 1); // Part
    updateChart(charts.neg, 2);  // Neg
    
    statusDiv.innerHTML = "Done.";

  } catch (e) {
    console.error(e);
    statusDiv.innerHTML = "Error: " + e.message;
  } finally {
    btn.innerHTML = 'ğŸ”„ ì‹¤í–‰ (Î¼1=1..23 Sweep)'; btn.disabled = false;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  initCharts();
  document.getElementById('runBtn').addEventListener('click', runSweep);
  runSweep();
});
</script>

</body>
</html>
