<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ì˜ë£Œì¢…ì‚¬ì í™ì—­ ë©´ì—­ ì „ëµ ë¯¼ê°ë„ ë¶„ì„ (Ternary Dots)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <style>
    .chart-container { position: relative; width: 100%; height: 350px; }
    /* ì»¨í…Œì´ë„ˆ ë„ˆë¹„ë¥¼ ëŠ˜ë¦¬ê³  ë¶ˆí•„ìš”í•œ aspect-ratio ì œê±° */
    .ternary-container {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      min-height: 400px; /* ë¡œë”© ì „ ìµœì†Œ ë†’ì´ í™•ë³´ */
    }
    .control-card { background: #ffffff; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); }
    input[type="number"] { accent-color: #2563eb; }
  </style>
</head>

<body class="bg-slate-50 text-slate-900 font-sans leading-relaxed">

<header class="bg-white border-b border-slate-200 sticky top-0 z-50">
  <div class="max-w-7xl mx-auto px-6 h-16 flex items-center justify-between">
    <div class="flex items-center gap-2">
      <span class="text-2xl">ğŸ¥</span>
      <h1 class="text-lg font-bold text-slate-800">HCW Measles Immunity Strategy Dashboard</h1>
    </div>
    <div class="text-xs text-slate-400 font-mono">MATLAB logic: mu_1_sensitivity.m</div>
  </div>
</header>

<main class="max-w-7xl mx-auto px-6 py-10 space-y-10">

  <section class="grid lg:grid-cols-3 gap-8">
    <div class="lg:col-span-1 space-y-6">
      <div class="control-card space-y-4">
        <h2 class="text-sm font-bold text-slate-500 uppercase tracking-wider">ì…ë ¥ (epsilon only)</h2>
        <div>
          <label class="block text-sm font-medium text-slate-700 mb-1">Turnover Scaling (Îµ)</label>
          <input type="number" id="epsilonInput" value="0" step="0.01" min="0"
                 class="w-full px-3 py-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 outline-none">
          <p class="text-[10px] text-slate-400 mt-1">pde_pop.mì˜ out_amt / inflow_weightì— ë™ì¼í•˜ê²Œ ë°˜ì˜ë©ë‹ˆë‹¤.</p>
        </div>

        <button id="runBtn"
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg transition-all shadow-md active:scale-95">
          ğŸ”„ ì‹¤í–‰ (Î¼1=1..23 Sweep)
        </button>

        <div class="text-[11px] text-slate-500 space-y-1">
          <div class="font-mono">t_span = 41 (Fixed)</div>
          <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-black"></span> Baseline: to_full, v_t=50</div>
          <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-[#C46E41]"></span> Scenario 1: to_neg, v_t=0</div>
          <div class="flex items-center gap-2"><span class="w-2 h-2 rounded-full bg-[#EDAF21]"></span> Scenario 2: to_full, v_t=0</div>
        </div>
        <div id="status" class="text-[11px] text-slate-500"></div>
      </div>
    </div>

    <div class="lg:col-span-2 space-y-6">
      <div class="bg-white p-8 rounded-2xl shadow-sm border border-slate-100">
        <h2 class="text-2xl font-bold mb-4 text-slate-800">Result 2 (mu_1_sensitivity.m) â€“ epsilon ì…ë ¥ ë²„ì „</h2>
        
        <div class="ternary-container mb-10">
          <!-- Canvasì— w-full í´ë˜ìŠ¤ ì¶”ê°€ -->
          <canvas id="ternaryChart" class="w-full"></canvas>
        </div>

        <hr class="my-8 border-slate-100">

        <div class="grid lg:grid-cols-3 gap-4">
          <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-50">
            <h3 class="text-xs font-bold text-center text-slate-400 mb-3">(A) Baseline</h3>
            <div class="chart-container"><canvas id="chartBase"></canvas></div>
          </div>
          <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-50">
            <h3 class="text-xs font-bold text-center text-slate-400 mb-3">(B) Scenario 1</h3>
            <div class="chart-container"><canvas id="chartS1"></canvas></div>
          </div>
          <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-50">
            <h3 class="text-xs font-bold text-center text-slate-400 mb-3">(C) Scenario 2</h3>
            <div class="chart-container"><canvas id="chartS2"></canvas></div>
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<footer class="max-w-7xl mx-auto px-6 py-10 border-t border-slate-200 text-center text-slate-400 text-xs">
  <p>ë³¸ ì‹œë®¬ë ˆì´í„°ëŠ” MATLAB ì—°êµ¬ ì½”ë“œë¥¼ ì›¹ í‘œì¤€ ê¸°ìˆ ë¡œ êµ¬í˜„í•œ ì‹œê°í™” ë„êµ¬ì…ë‹ˆë‹¤.</p>
</footer>

<script>
/** =========================
 * Constants & MATLAB Logic
 * ========================= */
const N_TOT = 2320;
const T_SPAN = 41;
const MU_RANGE = Array.from({length: 23}, (_, i) => i + 1);

const C_FULL = 'rgb(0,77,189)';
const C_PART = 'rgb(237,176,33)';
const C_NEG  = 'rgb(230,26,26)';

const COLOR_S1 = 'rgb(196, 110, 65)'; // MATLAB color_S1
const COLOR_S2 = 'rgb(237, 175, 33)'; // MATLAB color_S2

// ë ˆì´ì•„ì›ƒ ìƒìˆ˜ ì •ì˜
const LAYOUT = {
    marginLeft: 60,  // ì™¼ìª½ ë¼ë²¨ ê³µê°„ (S_Neg)
    marginRight: 60, // ì˜¤ë¥¸ìª½ ë¼ë²¨ ê³µê°„ (S_Part)
    marginTop: 40,   // ìœ„ìª½ ë¼ë²¨ ê³µê°„ (S_Full)
    marginBottom: 40 // ì•„ë˜ìª½ ì—¬ë°±
};

function simpsonIntegrate(f, t, n){
  if (t <= 0) return 0;
  n = Math.max(200, Math.floor(n||400));
  if (n % 2 === 1) n += 1;
  const h = t / n;
  let s = f(0) + f(t);
  for (let i=1; i<n; i++){
    const x = i*h;
    s += (i%2===0 ? 2 : 4) * f(x);
  }
  return (h/3) * s;
}

function gampdf(x, a, b){ if (x < 0) return 0; return jStat.gamma.pdf(x, a, b); }
function gamcdf(x, a, b){ if (x < 0) return 0; return jStat.gamma.cdf(x, a, b); }

function EstImm(param, tspan, intSteps){
  const P0 = 1.0;
  const alpha1 = param[0], mu1 = param[1], alpha2 = param[2];
  const beta1 = mu1 / alpha1, beta2 = (24 - mu1) / alpha2;
  const P = [], Part = [], Neg = [];
  for (let i=0; i<tspan.length; i++){
    const t = tspan[i];
    const F1 = gamcdf(t, alpha1, beta1);
    const P_t = P0 * (1 - F1);
    if (t === 0){
      P[i] = P_t; Part[i] = Number.EPSILON; Neg[i] = Number.EPSILON;
    } else {
      const integrand = (u) => gampdf(u, alpha1, beta1) * gamcdf(t-u, alpha2, beta2);
      const neg = P0 * simpsonIntegrate(integrand, t, intSteps) + Number.EPSILON;
      P[i] = P_t; Neg[i] = neg; Part[i] = 1 - P_t - neg;
    }
  }
  return { Full: P, Part, Neg };
}

function pdePop(year, epsilon){
  const Amax = 42, L = Amax, Ntot = 2320;
  const y_raw = [1,1,2,19,52,136,158,169,152,150,143,115,98,67,66,50,45,44,43,52,48,53,47,30,46,31,29,35,27,28,23,32,26,27,14,38,38,37,37,37,37,37];
  let D = y_raw.map(v => v/2320);
  const sumD = D.reduce((a,b)=>a+b,0);
  D = D.map(v => v/sumD * Ntot);
  const out_amt = new Array(L).fill(0);
  for (let a=0; a<L-1; a++) out_amt[a] = Math.max(D[a]-D[a+1], 0) + D[a]*epsilon;
  out_amt[L-1] = D[L-1] + D[L-1]*epsilon;
  const inflow_weight = new Array(L).fill(0);
  inflow_weight[0] = D[0] + D[0]*epsilon;
  for (let a=1; a<L; a++) inflow_weight[a] = Math.max(D[a]-D[a-1], 0) + D[a]*epsilon;
  let sumW = inflow_weight.reduce((a,b)=>a+b,0);
  for (let a=0; a<L; a++) inflow_weight[a] /= sumW;
  const P = Array.from({length:L}, ()=> new Array(year+1).fill(0));
  for (let a=0; a<L; a++) P[a][0] = D[a];
  let C = Array.from({length:L}, ()=> new Array(year).fill(0));
  for (let t=1; t<=year; t++){
    let TotalStock = new Array(L).fill(0);
    for (let a=0; a<L; a++){
      let s = P[a][t-1];
      for (let k=0; k<t-1; k++) s += C[a][k];
      TotalStock[a] = Math.max(s, 1e-9);
    }
    const take = new Array(L);
    for (let a=0; a<L; a++) take[a] = Math.min(out_amt[a], TotalStock[a]);
    const out_P = new Array(L), P_after = new Array(L);
    for (let a=0; a<L; a++){
      out_P[a] = (P[a][t-1] / TotalStock[a]) * take[a];
      P_after[a] = Math.max(P[a][t-1] - out_P[a], 0);
    }
    let C_after = Array.from({length:L}, ()=> new Array(t-1).fill(0));
    let out_C_all_sum = 0;
    if (t > 1){
      for (let k=0; k<t-1; k++){
        for (let a=0; a<L; a++){
          const out_C_k = (C[a][k] / TotalStock[a]) * take[a];
          C_after[a][k] = Math.max(C[a][k] - out_C_k, 0);
          out_C_all_sum += out_C_k;
        }
      }
    }
    const P_next = new Array(L).fill(0);
    for (let a=1; a<L; a++) P_next[a] = P_after[a-1];
    const C_next = Array.from({length:L}, ()=> new Array(year).fill(0));
    if (t > 1){
      for (let k=0; k<t-1; k++) for (let a=1; a<L; a++) C_next[a][k+1] = C_after[a-1][k];
    }
    const out_total = out_P.reduce((s,x)=>s+x,0) + out_C_all_sum;
    for (let a=0; a<L; a++) C_next[a][0] = out_total * inflow_weight[a];
    for (let a=0; a<L; a++) P[a][t] = P_next[a];
    C = C_next;
  }
  return { C, P };
}

function matrixNoVacToFull(param, year, v_t, epsilon){
  const tspan = Array.from({length: 51+20+year + 1}, (_,i)=>i);
  const IMM_G1 = EstImm(param, tspan, 400);
  const g2full = [78,88,78,97,92,91,94,98,100,96,91,98,98,90,96,94,97,91,87,97,100,93,96,96,100,100,100,93].map(v=>v/100);
  const IMM_G2 = g2full.map(v => [v, 0, 1-v]);
  const Q0 = pdePop(year, epsilon).C;
  let pop_matrix = null;
  for (let T=1; T<=year; T++){
    const res = pdePop(T, epsilon);
    const P = res.P;
    pop_matrix = [Array.from({length:T+1}, ()=>new Array(42).fill(0)), Array.from({length:T+1}, ()=>new Array(42).fill(0)), Array.from({length:T+1}, ()=>new Array(42).fill(0))];
    const limit_idx = Math.min(7+T, 42);
    for (let i=0; i<3; i++) for (let a=0; a<limit_idx; a++){
      const t_imm = 14 + a;
      const imm = (i===0?IMM_G1.Full[t_imm] : i===1?IMM_G1.Part[t_imm] : IMM_G1.Neg[t_imm]);
      pop_matrix[i][0][a] = imm * P[a][T];
    }
    for (let j=2; j<=T+1; j++){
      const tenure = j-1, recruit_year = T - tenure + 1;
      let pop_count = new Array(limit_idx).fill(0);
      if (tenure <= Q0[0].length) for (let a=0; a<limit_idx; a++) pop_count[a] = Q0[a][tenure-1];
      if (recruit_year <= v_t){
        for (let i=0; i<3; i++) for (let a=0; a<limit_idx; a++){
          const t_imm = 14 + a;
          const imm = (i===0?IMM_G1.Full[t_imm] : i===1?IMM_G1.Part[t_imm] : IMM_G1.Neg[t_imm]);
          pop_matrix[i][j-1][a] = pop_count[a] * imm;
        }
      } else {
        const tV = j-1;
        for (let i=0; i<3; i++){
          const immV = (i===0?IMM_G1.Full[tV] : i===1?IMM_G1.Part[tV] : IMM_G1.Neg[tV]);
          for (let a=0; a<limit_idx; a++) pop_matrix[i][j-1][a] = pop_count[a] * immV;
        }
      }
    }
    for (const i of [0, 2]){
      const idx_start = 8 + T, idx_end = Math.min(42, 35 + T);
      if (idx_start <= 42){
        const start0 = idx_start - 1, len_req = (idx_end - 1) - start0 + 1;
        let G2_probs = new Array(len_req).fill(0);
        if (T > 7){
          const g2_idx = []; for (let k=(T-6); k<=28; k++) g2_idx.push(k);
          const g2_trim = g2_idx.slice(0, len_req).map(v=>v-1);
          for (let m=0; m<len_req; m++) G2_probs[m] = IMM_G2[g2_trim[m]][i];
        } else { for (let m=0; m<len_req; m++) G2_probs[m] = IMM_G2[m][i]; }
        for (let m=0; m<len_req; m++){ const a = start0 + m; pop_matrix[i][0][a] = G2_probs[m] * P[a][T]; }
        for (let j=2; j<=T+1; j++){
          const tenure = j-1, recruit_year = T - tenure + 1;
          if (recruit_year <= v_t){
            for (let m=0; m<len_req; m++) pop_matrix[i][j-1][start0+m] = ((tenure<=Q0[0].length)?Q0[start0+m][tenure-1]:0) * G2_probs[m];
          } else {
            for (let m=0; m<len_req; m++) pop_matrix[i][j-1][start0+m] = (i===0 && tenure<=Q0[0].length) ? Q0[start0+m][tenure-1] : 0;
          }
        }
      }
    }
  }
  return pop_matrix;
}

function matrixNoVacToNeg(param, year, v_t, epsilon){
  const clamp = (x, lo, hi) => Math.min(Math.max(x, lo), hi);
  const tspan = Array.from({length: 51 + 20 + year + 1}, (_, i) => i);
  const IMM_G1 = EstImm(param, tspan, 400);
  const g2full = [78,88,78,97,92,91,94,98,100,96,91,98,98,90,96,94,97,91,87,97,100,93,96,96,100,100,100,93].map(v => v/100);
  const IMM_G2 = g2full.map(v => [v, 0, 1 - v]);
  const resY = pdePop(year, epsilon);
  const Q0 = resY.C;
  const G1_Neg = IMM_G1.Neg;
  const Q1_ = Array.from({length: 42}, () => new Array(year).fill(0));
  const max_row = 42;
  for (let T = 1; T <= year; T++){
    if (T > v_t){
      const idx_limit = Math.min(T + 7, max_row);
      const Neg_vaccination = new Array(idx_limit);
      for (let a = 0; a < idx_limit; a++){
        Neg_vaccination[a] = (Q0[a][0] || 0) * (G1_Neg[18 + a] || 0);
      }
      const zerosLen = Math.min(year - T, 42);
      const Q_ratio = [];
      for (let z = 0; z < zerosLen; z++) Q_ratio.push(0);
      for (let a = 0; a < idx_limit; a++){
        const denom = Q0[a][0] || 0;
        Q_ratio.push(denom > 0 ? (Neg_vaccination[a] / denom) : 0);
      }
      const col = year - T;
      const L = Math.min(42, Q_ratio.length);
      for (let r = 0; r < L; r++){
        const v = Q_ratio[r];
        Q1_[r][col] = Number.isFinite(v) ? v : 0;
      }
    }
  }
  const V = Array.from({length: 42}, () => new Array(year).fill(0));
  const Q = Array.from({length: 42}, () => new Array(year).fill(0));
  for (let a = 0; a < 42; a++){
    for (let k = 0; k < year; k++){
      const q0 = Q0[a][k] || 0;
      const q1 = Q1_[a][k] || 0;
      V[a][k] = q0 * q1;
      Q[a][k] = q0 * (1 - q1);
    }
  }
  let pop_matrix = null;
  for (let T = 1; T <= year; T++){
    const res = pdePop(T, epsilon);
    const P = res.P;
    const C = res.C;
    pop_matrix = [
      Array.from({length: T + 1}, () => new Array(42).fill(0)),
      Array.from({length: T + 1}, () => new Array(42).fill(0)),
      Array.from({length: T + 1}, () => new Array(42).fill(0)),
    ];
    const idx_limit = Math.min(7 + T, max_row);
    for (let i = 0; i < 3; i++){
      for (let a = 0; a < idx_limit; a++){
        const t_imm = 14 + a;
        const imm = (i===0 ? (IMM_G1.Full[t_imm] || 0) : i===1 ? (IMM_G1.Part[t_imm] || 0) : (IMM_G1.Neg[t_imm] || 0));
        pop_matrix[i][0][a] = imm * (P[a][T] || 0);
      }
      for (let j = 2; j <= T + 1; j++){
        for (let a = 0; a < idx_limit; a++){
          const t_age = 14 + a;
          const imm_age = (i===0 ? (IMM_G1.Full[t_age] || 0) : i===1 ? (IMM_G1.Part[t_age] || 0) : (IMM_G1.Neg[t_age] || 0));
          const t_tenure = (j - 2);
          const imm_ten = (i===0 ? (IMM_G1.Full[t_tenure] || 0) : i===1 ? (IMM_G1.Part[t_tenure] || 0) : (IMM_G1.Neg[t_tenure] || 0));
          const qPop = (Q[a] && Q[a][j - 2]) ? Q[a][j - 2] : 0;
          const vPop = (V[a] && V[a][j - 2]) ? V[a][j - 2] : 0;
          pop_matrix[i][j - 1][a] = imm_age * qPop + imm_ten * vPop;
        }
      }
    }
    for (const i of [0, 2]){
      const idx_start = 8 + T;
      const idx_end = Math.min(42, 35 + T);
      if (idx_start <= 42){
        const start0 = idx_start - 1;
        const end0 = idx_end - 1;
        const len = end0 - start0 + 1;
        for (let m = 0; m < len; m++){
          const a = start0 + m;
          const g2row = (T > 7) ? clamp((T - 6 - 1) + m, 0, 27) : m;
          pop_matrix[i][0][a] = (IMM_G2[g2row]?.[i] || 0) * (P[a][T] || 0);
        }
        for (let j = 2; j <= T + 1; j++){
          for (let m = 0; m < len; m++){
            const a = start0 + m;
            const g2row = (T > 7) ? clamp((T - 6 - 1) + m, 0, 27) : m;
            const pop = (C[a] && (j - 2) < C[a].length) ? (C[a][j - 2] || 0) : 0;
            pop_matrix[i][j - 1][a] = (IMM_G2[g2row]?.[i] || 0) * pop;
          }
        }
      }
    }
    const S3 = [38,38,37,37,37,37,37];
    if (T < 7){
      const from = 36 + T;
      for (let col = from; col <= 42; col++){
        const idx = col - from;
        pop_matrix[0][0][col - 1] = S3[idx];
      }
    }
  }
  return pop_matrix;
}

function runSimulation(func, theta, t_span, v_t, epsilon){
  const pm = func(theta, t_span, v_t, epsilon);
  let f=0, p=0, n=0;
  for (let i=0; i<pm[0].length; i++) for (let j=0; j<pm[0][i].length; j++){ f+=pm[0][i][j]; p+=pm[1][i][j]; n+=pm[2][i][j]; }
  return [f/N_TOT, p/N_TOT, n/N_TOT];
}

/** =========================
 * Ternary Plot Drawing Logic
 * ========================= */
function drawTernaryFrame(ctx, w, h_tri) {
  const { marginLeft, marginRight, marginTop, marginBottom } = LAYOUT;
  
  const triW = w - marginLeft - marginRight;
  const triCenterX = marginLeft + triW / 2;
  
  const topY = marginTop;
  const bottomY = marginTop + h_tri;
  const leftX = marginLeft;
  const rightX = marginLeft + triW;

  ctx.clearRect(0, 0, w, h_tri + marginTop + marginBottom + 50);

  // Background patches (Shading)
  // íˆ¬ëª…ë„ë¥¼ 0.05 -> 0.1ë¡œ ë†’ì—¬ì„œ ì˜ ë³´ì´ê²Œ ìˆ˜ì •
  const h = h_tri;
  
  // Full area (Blue)
  ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
  ctx.beginPath();
  ctx.moveTo(triCenterX, topY + h/2); ctx.lineTo(triCenterX - triW/4, topY + h/2); ctx.lineTo(triCenterX, topY); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(triCenterX, topY + h/2); ctx.lineTo(triCenterX + triW/4, topY + h/2); ctx.lineTo(triCenterX, topY); ctx.fill();

  // Part area (Yellow)
  ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
  ctx.beginPath();
  ctx.moveTo(triCenterX, bottomY); ctx.lineTo(rightX, bottomY); ctx.lineTo(triCenterX + triW/4, topY + h/2); ctx.fill();

  // Neg area (Red)
  ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
  ctx.beginPath();
  ctx.moveTo(leftX, bottomY); ctx.lineTo(triCenterX, bottomY); ctx.lineTo(triCenterX - triW/4, topY + h/2); ctx.fill();

  // Frame
  ctx.strokeStyle = '#000'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(leftX, bottomY); ctx.lineTo(rightX, bottomY); ctx.lineTo(triCenterX, topY); ctx.closePath(); ctx.stroke();

  // Mid-lines
  ctx.setLineDash([5, 5]); ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(triCenterX, bottomY); ctx.lineTo(triCenterX + triW/4, topY + h/2); ctx.lineTo(triCenterX - triW/4, topY + h/2); ctx.closePath(); ctx.stroke();
  ctx.setLineDash([]);

  // Labels
  ctx.font = 'bold 16px sans-serif'; 
  
  ctx.fillStyle = C_FULL; ctx.textAlign = 'center'; 
  ctx.fillText('S_Full', triCenterX, topY - 15);
  
  ctx.fillStyle = C_NEG;  ctx.textAlign = 'right';  
  ctx.fillText('S_Neg', leftX - 10, bottomY + 5);
  
  ctx.fillStyle = C_PART; ctx.textAlign = 'left';   
  ctx.fillText('S_Part', rightX + 10, bottomY + 5);
}

function toScreen(data, w, h_tri) {
  const { marginLeft, marginRight, marginTop } = LAYOUT;
  const triW = w - marginLeft - marginRight;
  
  const full = data[0], part = data[1], neg = data[2];
  const x = marginLeft + triW * (part + 0.5 * full);
  const y = (marginTop + h_tri) - h_tri * full;
  return { x, y };
}

/** =========================
 * Main App Logic
 * ========================= */
let charts = { base:null, s1:null, s2:null };

function initCharts(){
  const cfg = (ctx) => ({
    type: 'line',
    data: { labels: MU_RANGE, datasets: [
      { label:'S_Full', data:[], borderColor:C_FULL, backgroundColor:C_FULL, pointStyle:'triangle', pointRadius:3, tension:0.1 },
      { label:'S_Part', data:[], borderColor:C_PART, backgroundColor:C_PART, pointStyle:'rect', pointRadius:3, tension:0.1 },
      { label:'S_Neg',  data:[], borderColor:C_NEG,  backgroundColor:C_NEG,  pointStyle:'circle', pointRadius:3, tension:0.1 }
    ]},
    options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{min:0, max:1}, x:{title:{display:true, text:'Î¼1'}} } }
  });
  charts.base = new Chart(document.getElementById('chartBase'), cfg());
  charts.s1   = new Chart(document.getElementById('chartS1'), cfg());
  charts.s2   = new Chart(document.getElementById('chartS2'), cfg());

  // ì°¨íŠ¸ ì´ˆê¸°í™” ì‹œì ì— ë¹ˆ Ternary í”„ë ˆì„ ë¨¼ì € ê·¸ë¦¬ê¸°
  initTernary();
}

// ìº”ë²„ìŠ¤ í¬ê¸° ê³„ì‚° ë° ì´ˆê¸° í”„ë ˆì„ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ë¶„ë¦¬)
function initTernary() {
  const canvas = document.getElementById('ternaryChart');
  const ctx = canvas.getContext('2d');
  
  // ì•ˆì „ì¥ì¹˜: offsetWidthê°€ 0ì´ë©´ ê¸°ë³¸ê°’ 600 ì‚¬ìš©
  const w = canvas.width = (canvas.offsetWidth || 800);
  
  const { marginLeft, marginRight, marginTop, marginBottom } = LAYOUT;
  const triW = w - marginLeft - marginRight;
  const h_tri = triW * (Math.sqrt(3)/2);
  
  canvas.height = h_tri + marginTop + marginBottom;

  drawTernaryFrame(ctx, w, h_tri);
  return { ctx, w, h_tri };
}

async function runSweep(){
  const btn = document.getElementById('runBtn');
  const eps = parseFloat(document.getElementById('epsilonInput').value) || 0;
  btn.disabled = true; btn.innerHTML = 'â³ ê³„ì‚° ì¤‘...';

  try {
      // 1. ê³„ì‚° ì‹œì‘ ì „, í”„ë ˆì„ ë¦¬ì…‹ (í¬ê¸° ì¬ì¡°ì •)
      const { ctx, w, h_tri } = initTernary();

      const resB = [], resS1 = [], resS2 = [];
      for (let mu1 of MU_RANGE){
        const theta = [1, mu1, 1, 0];
        resB.push(runSimulation(matrixNoVacToFull, theta, T_SPAN, 50, eps));
        resS1.push(runSimulation(matrixNoVacToNeg, theta, T_SPAN, 0, eps));
        resS2.push(runSimulation(matrixNoVacToFull, theta, T_SPAN, 0, eps));
        if (mu1 % 5 === 0) await new Promise(r=>setTimeout(r,0));
      }

      // Update Line Charts
      const updateLine = (chart, data) => {
        chart.data.datasets[0].data = data.map(d=>d[0]);
        chart.data.datasets[1].data = data.map(d=>d[1]);
        chart.data.datasets[2].data = data.map(d=>d[2]);
        chart.update();
      };
      updateLine(charts.base, resB);
      updateLine(charts.s1, resS1);
      updateLine(charts.s2, resS2);

      // 2. Draw Dots (í”„ë ˆì„ ìœ„ì— ë§ê·¸ë¦¬ê¸°)
      // ì´ë¯¸ initTernaryì—ì„œ drawTernaryFrameì„ í˜¸ì¶œí–ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” drawDotsë§Œ í˜¸ì¶œí•˜ë©´ ë˜ì§€ë§Œ,
      // í˜¹ì‹œ ëª¨ë¥¼ ê²¹ì¹¨ ë°©ì§€ë¥¼ ìœ„í•´ ë‹¤ì‹œ í´ë¦¬ì–´í•˜ê³  ê·¸ë ¤ë„ ë¨. 
      // ì—¬ê¸°ì„œëŠ” ë®ì–´ì“°ê¸° ìœ„í•´ ë‹¤ì‹œ í˜¸ì¶œ (ë°°ê²½ ìœ ì§€)
      drawTernaryFrame(ctx, w, h_tri);

      const drawDots = (data, color, label) => {
        // Line
        ctx.strokeStyle = color; 
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        data.forEach((d, i) => {
          const p = toScreen(d, w, h_tri);
          if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();
        ctx.globalAlpha = 1.0; 

        // Dots
        ctx.fillStyle = color;
        data.forEach((d, i) => {
          const p = toScreen(d, w, h_tri);
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI*2); 
          ctx.fill();
        });

        // Start (Circle)
        const p1 = toScreen(data[0], w, h_tri);
        ctx.fillStyle = '#fff'; ctx.strokeStyle = color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(p1.x, p1.y, 5, 0, Math.PI*2); ctx.fill(); ctx.stroke();

        // End (X)
        const pEnd = toScreen(data[data.length-1], w, h_tri);
        ctx.strokeStyle = color; ctx.lineWidth = 3;
        const size = 5;
        ctx.beginPath();
        ctx.moveTo(pEnd.x - size, pEnd.y - size); ctx.lineTo(pEnd.x + size, pEnd.y + size);
        ctx.moveTo(pEnd.x + size, pEnd.y - size); ctx.lineTo(pEnd.x - size, pEnd.y + size);
        ctx.stroke();
      };

      drawDots(resB, '#000', 'Base');
      drawDots(resS1, COLOR_S1, 'S1');
      drawDots(resS2, COLOR_S2, 'S2');

      // Legend
      const drawLegend = () => {
        const lx = w - 110, ly = 30;
        ctx.textAlign = 'left';
        
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(lx, ly, 3, 0, Math.PI*2); ctx.fill();
        ctx.font = '12px sans-serif'; ctx.fillStyle = '#000'; ctx.fillText('Baseline', lx + 12, ly + 4);

        ctx.fillStyle = COLOR_S1; ctx.beginPath(); ctx.arc(lx, ly + 20, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = COLOR_S1; ctx.fillText('Scenario 1', lx + 12, ly + 24);

        ctx.fillStyle = COLOR_S2; ctx.beginPath(); ctx.arc(lx, ly + 40, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = COLOR_S2; ctx.fillText('Scenario 2', lx + 12, ly + 44);

        const markerY = ly + 70;
        ctx.fillStyle = '#999'; ctx.fillRect(lx - 5, markerY - 10, 100, 1);

        ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(lx, markerY, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#555'; ctx.fillText('Î¼1 = 1', lx + 12, markerY + 4);

        const xY = markerY + 20;
        ctx.beginPath(); 
        ctx.moveTo(lx - 3, xY - 3); ctx.lineTo(lx + 3, xY + 3);
        ctx.moveTo(lx + 3, xY - 3); ctx.lineTo(lx - 3, xY + 3);
        ctx.stroke();
        ctx.fillText('Î¼1 = 23', lx + 12, xY + 4);
      }
      drawLegend();

  } catch(e) {
      console.error(e);
      document.getElementById('status').innerText = 'Error: ' + e.message;
  } finally {
      btn.innerHTML = 'ğŸ”„ ì‹¤í–‰ (Î¼1=1..23 Sweep)'; btn.disabled = false;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  initCharts(); // initTernary()ê°€ ë‚´ë¶€ì—ì„œ í˜¸ì¶œë¨
  document.getElementById('runBtn').addEventListener('click', runSweep);
  runSweep();
});
</script>

</body>
</html>
